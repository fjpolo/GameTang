import argparse
import os

# --- Constants ---
# Assuming a standard byte-addressable memory where each element stores 8 bits
DATA_WIDTH = 8
# The script will load the entire file into a linear array.

def load_data(input_path):
    """
    Loads data from the specified file path, handling .bin (raw bytes)
    and .hex (ASCII hexadecimal dump) formats.
    Returns a list of 8-bit integers (bytes).
    """
    ext = os.path.splitext(input_path)[1].lower()
    data_bytes = []

    if ext == '.bin':
        print(f"Reading raw binary data from {input_path}")
        try:
            with open(input_path, 'rb') as f:
                data_bytes = list(f.read())
        except FileNotFoundError:
            raise FileNotFoundError(f"Error: Input file not found at {input_path}")

    elif ext == '.hex':
        print(f"Reading ASCII hexadecimal data from {input_path}")
        try:
            with open(input_path, 'r') as f:
                content = f.read().replace('\n', '').replace('\r', '').strip()
                # Remove common non-hex characters (spaces, tabs, commas, comments)
                cleaned_content = "".join(c for c in content if c in '0123456789abcdefABCDEF')

                if len(cleaned_content) % 2 != 0:
                    print("Warning: Hex file has an odd number of nibbles. Truncating the last nibble.")
                    cleaned_content = cleaned_content[:-1]

                for i in range(0, len(cleaned_content), 2):
                    byte_str = cleaned_content[i:i+2]
                    try:
                        data_bytes.append(int(byte_str, 16))
                    except ValueError:
                        print(f"Error parsing hex byte: '{byte_str}'")
                        # Skip corrupted byte
                        continue
        except FileNotFoundError:
            raise FileNotFoundError(f"Error: Input file not found at {input_path}")
    else:
        raise ValueError(f"Error: Unsupported file extension '{ext}'. Only .bin or .hex are supported.")

    print(f"Successfully loaded {len(data_bytes)} bytes.")
    return data_bytes

def generate_verilog_initializer(data_bytes, mem_name="bsram_memory", output_path="bsram_init.v"):
    """
    Generates a Verilog initial block to populate a memory array.
    """
    if not data_bytes:
        print("Warning: Data list is empty. Skipping file generation.")
        return

    mem_size = len(data_bytes)
    address_width = (mem_size - 1).bit_length()
    
    # Verilog header for the memory declaration and initial block
    verilog_code = (
        f"// --- Memory Initializer Generated by mem_initializer.py ---\n"
        f"// Total size: {mem_size} bytes\n"
        f"// Address width: {address_width} bits ({mem_name}[{mem_size - 1}:0])\n"
        f"// Data width: {DATA_WIDTH} bits\n\n"
        
        # NOTE: The actual memory declaration (e.g., reg [7:0] bsram_memory [0:{mem_size - 1}];)
        # must be present in your Verilog module!
        
        f"initial begin\n"
        f"  \$display(\"Initializing {mem_name} with {mem_size} bytes...\");\n"
    )

    # Use $readmemh if the input was hex or binary, it's often more compact,
    # but since the request asked for an 'initial begin...end' block with direct assignments,
    # and to strictly avoid $readmemh (which can fail with illegal characters),
    # we'll use direct assignments for maximum compatibility and corruption immunity.
    
    # We will write 8 assignments per line for readability
    bytes_per_line = 8
    
    for i, byte_value in enumerate(data_bytes):
        # Start a new line and indentation for every batch of 8 assignments
        if i % bytes_per_line == 0:
            verilog_code += "\n  "
        
        # Format the assignment: mem_name[address] = 8'hXX;
        hex_value = f"{byte_value:02X}"
        verilog_code += f"{mem_name}[{i}] = {DATA_WIDTH}'h{hex_value}; "
        
    verilog_code += (
        f"\n\n  \$display(\"Initialization complete.\");\n"
        f"end // initial\n"
        f"// ------------------------------------------------------------------\n"
    )

    try:
        with open(output_path, 'w') as f:
            f.write(verilog_code)
        print(f"\nSuccess! Verilog memory initializer written to: {output_path}")
    except Exception as e:
        print(f"Error writing output file: {e}")

def main():
    parser = argparse.ArgumentParser(
        description="Convert .bin or .hex files into a Verilog memory initialization block.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "input_file",
        help="Path to the input file (.bin for raw bytes, .hex for ASCII hex dump)."
    )
    parser.add_argument(
        "-o", "--output_file",
        default="bsram_init.v",
        help="Path for the output Verilog file (default: bsram_init.v)."
    )
    parser.add_argument(
        "-m", "--memory_name",
        default="bsram_memory",
        help="Name of the memory array in Verilog (e.g., prg_rom, bsram_memory). (default: bsram_memory)."
    )

    args = parser.parse_args()

    try:
        data = load_data(args.input_file)
        generate_verilog_initializer(data, args.memory_name, args.output_file)
    except (FileNotFoundError, ValueError) as e:
        print(e)
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    main()